# 6 种限流实现方案
## 限流分类
限流的实现方案有很多种，磊哥这里稍微理了一下，限流的分类如下所示：

1. 合法性验证限流：比如验证码、IP 黑名单等，这些手段可以有效的防止恶意攻击和爬虫采集；
2. 容器限流：比如 Tomcat、Nginx 等限流手段，其中 Tomcat 可以设置最大线程数（maxThreads），当并发超过最大线程数会排队等待执行；而 Nginx 提供了两种限流手段：一是控制速率，二是控制并发连接数；
3. 服务端限流：比如我们在服务器端通过限流算法实现限流，此项也是我们本文介绍的重点。

合法性验证限流为最常规的业务代码，就是普通的验证码和 IP 黑名单系统，本文就不做过多的叙述了，我们重点来看下后两种限流的实现方案：容器限流和服务端限流。

## 容器限流

### Tomcat限流

以tomcat8.5版本为例，最大线程数再conf/server.xml配置中，如下所示：

```xml
<Connector port="8080" protocol="HTTP/1.1"
          connectionTimeout="20000"
          maxThreads="150"
          redirectPort="8443" />
```

其中`maxThreads`就是tomcat的最大线程数，当请求的并发大于此值时，请求就会排队执行，以达到限流的目的

>maxThreads 的值可以适当的调大一些，此值默认为 150（Tomcat 版本 8.5.42），但这个值也不是越大越好，要看具体的硬件配置，需要注意的是每开启一个线程需要耗用 1MB 的 JVM 内存空间用于作为线程栈之用，并且线程越多 GC 的负担也越重。最后需要注意一下，操作系统对于进程中的线程数有一定的限制，Windows 每个进程中的线程数不允许超过 2000，Linux 每个进程中的线程数不允许超过 1000。

### Nginx限流

Nginx提供了两种限流手段：一是控制速率，二是控制并发连接数。

#### 控制速率

我们需要使用`limit_req_zone`来限制单位时间内的请求数，即速率限制，配置示例如下：

```json
limit_req_zone $binary_remote_addr zone=mylimit:10m rate=2r/s;
server { 
    location / { 
        limit_req zone=mylimit;
    }
}
```

以上配置表示，限制每个 IP 访问的速度为 2r/s，因为 Nginx 的限流统计是基于毫秒的，我们设置的速度是 2r/s，转换一下就是 500ms 内单个 IP 只允许通过 1 个请求，从 501ms 开始才允许通过第 2 个请求。

我们使用单 IP 在 10ms 内发并发送了 6 个请求的执行结果如下：
![title](https://raw.githubusercontent.com/lllpla/img/master/gitnote/2020/05/18/1589765420579-1589765420639.png)
从以上结果可以看出他的执行符合我们的预期，只有 1 个执行成功了，其他的 5 个被拒绝了（第 2 个在 501ms 才会被正常执行）。

#### 速率限制升级版

上面的速录控制虽然很精准，但是用于真实环境未免太苛刻了，真实情况下我们应该控制一个ip单位总时间内的总访问次数，而不是像上面那么精确到毫秒。因此我们可以使用burst关键字开启此设置，示例配置如下：

