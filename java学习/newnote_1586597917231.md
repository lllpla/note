# 为什么阿里巴巴不建议在for循环中使用"+"进行字符串拼接 

## 字符串拼接  

字符串拼接是我们在Java代码中比较经常要做的事情，就是把多个字符串拼接到一起。 

我们都知道，**String是Java中一个不可变的类，所以他一旦被实例化就无法被修改。**

>不可变类的实例一旦创建，其成员变量的值就不能被修改。这样设计有很多好处，比如可以缓存hashcode、使用更加便利以及更加安全等。 

但是，既然字符串是不可变的，那么字符串拼接又是怎么回事呢？ 

### 字符串不变性与字符串拼接
其实，所有的所谓字符串拼接，都是重新生成了一个新的字符串。下面一段字符串拼接代码： 

```java
String s = "abcd"; 
s = s.concat("ef"); 
```
其实最后我们得到的s已经是一个新的字符串了。如下图  
![title](https://raw.githubusercontent.com/lllpla/img/master/gitnote/2020/04/11/1586598030950-1586598031667.png)
s中保存的是一个重新创建出来的String对象的引用。 

那么，在Java中，到底如何进行字符串拼接呢？字符串拼接有很多种方式，这里简单介绍几种比较常用的。 

### 使用+拼接字符串

在Java中，拼接字符串最简单的方式就是直接使用符号+来拼接。如： 
```java
String wechat = "Hollis"; 
String introduce = "每日更新Java相关技术文章"; 
String hollis = wechat + "," + introduce; 
```
这里要特别说明一点，有人把Java中使用+拼接字符串的功能理解为**运算符重载**。其实并不是，**Java是不支持运算符重载的**。这其实只是Java提供的一个语法糖。后面再详细介绍。 
运算符重载：在计算机程序设计中，运算符重载（英语：operator overloading）是多态的一种。运算符重载，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型。 

>语法糖：语法糖（Syntactic sugar），也译为糖衣语法，是由英国计算机科学家彼得·兰丁发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。 

### Concat 
除了使用+拼接字符串之外，还可以使用String类中的方法concat方法来拼接字符串。如： 
```java
String wechat = "Hollis"; 
String introduce = "每日更新Java相关技术文章"; 
String hollis = wechat.concat(",").concat(introduce);
```
### StringBuffer 

关于字符串，Java中除了定义了一个可以用来定义**字符串常量**的String类以外，还提供了可以用来定义字符串变量的StringBuffer类，它的对象是可以扩充和修改的。 

使用StringBuffer可以方便的对字符串进行拼接。如： 
```java
StringBuffer wechat = new StringBuffer("Hollis"); 
String introduce = "每日更新Java相关技术文章"; 
StringBuffer hollis = wechat.append(",").append(introduce); 
```
### StringBuilder 

除了StringBuffer以外，还有一个类StringBuilder也可以使用，其用法和StringBuffer类似。如： 
```java
StringBuilder wechat = new StringBuilder("Hollis"); 
String introduce = "每日更新Java相关技术文章"; 
StringBuilder hollis = wechat.append(",").append(introduce); 
```
### StringUtils.join 

除了JDK中内置的字符串拼接方法，还可以使用一些开源类库中提供的字符串拼接方法名，如apache.commons中提供的StringUtils类，其中的join方法可以拼接字符串。 
```java
String wechat = "Hollis"; 
String introduce = "每日更新Java相关技术文章"; 
System.out.println(StringUtils.join(wechat, ",", introduce)); 
```
这里简单说一下，StringUtils中提供的join方法，最主要的功能是：将数组或集合以某拼接符拼接到一起形成新的字符串，如： 
```java
String []list  ={"Hollis","每日更新Java相关技术文章"}; 
String result= StringUtils.join(list,","); 
System.out.println(result); 
//结果：Hollis,每日更新Java相关技术文章 
```
并且，Java8中的String类中也提供了一个静态的join方法，用法和StringUtils.join类似。 

以上就是比较常用的五种在Java种拼接字符串的方式，那么到底哪种更好用呢？为什么阿里巴巴Java开发手册中不建议在循环体中使用+进行字符串拼接呢？ 
(阿里巴巴Java开发手册中关于字符串拼接的规约) 

## 使用+拼接字符串的实现原理 
前面提到过，使用+拼接字符串，其实只是Java提供的一个语法糖， 那么，我们就来解一解这个语法糖，看看他的内部原理到底是如何实现的。 

还是这样一段代码。我们把他生成的字节码进行反编译，看看结果。 
```java
String wechat = "Hollis"; 
String introduce = "每日更新Java相关技术文章"; 
String hollis = wechat + "," + introduce; 
```
反编译后的内容如下，反编译工具为jad。 
```java
String wechat = "Hollis"; 
String introduce = "\u6BCF\u65E5\u66F4\u65B0Java\u76F8\u5173\u6280\u672F\u6587\u7AE0"; 

//每日更新Java相关技术文章 
String hollis = (new StringBuilder()).append(wechat).append(",").append(introduce).toString(); 
```
通过查看反编译以后的代码，我们可以发现，原来字符串常量在拼接过程中，是将String转成了StringBuilder后，使用其append方法进行处理的。 

那么也就是说，**Java中的+对字符串的拼接，其实现原理是使用StringBuilder.append**。 
## concat是如何实现的 

我们再来看一下concat方法的源代码，看一下这个方法又是如何实现的。 
```java
public String concat(String str) { 
    int otherLen = str.length(); 
    if (otherLen == 0) { 
        return this; 
    } 
    int len = value.length; 
    char buf[] = Arrays.copyOf(value, len + otherLen); 
    str.getChars(buf, len); 
    return new String(buf, true); 
} 
```
这段代码首先创建了一个字符数组，长度是已有字符串和待拼接字符串的长度之和，再把两个字符串的值复制到新的字符数组中，并使用这个字符数组创建一个新的String对象并返回。 

通过源码我们也可以看到，**经过concat方法，其实是new了一个新的String**，这也就呼应到前面我们说的字符串的不变性问题上了。 

## StringBuffer和StringBuilder 

接下来我们看看StringBuffer和StringBuilder的实现原理。 

和String类类似，StringBuilder类也封装了一个字符数组，定义如下： 
```char[] value; ```
与String不同的是，它并不是final的，所以他是可以修改的。另外，与String不同，字符数组中不一定所有位置都已经被使用，它有一个实例变量，表示数组中已经使用的字符个数，定义如下： 
```int count; ```
其append源码如下： 
```java
public StringBuilder append(String str) { 
    super.append(str); 
    return this; 
} 
```
该类继承了AbstractStringBuilder类，看下其append方法： 
```java
public AbstractStringBuilder append(String str) { 
    if (str == null) 
        return appendNull(); 
    int len = str.length(); 
    ensureCapacityInternal(count + len); 
    str.getChars(0, len, value, count); 
    count += len; 
    return this; 
} 
```
**append会直接拷贝字符到内部的字符数组中，如果字符数组长度不够，会进行扩展。**

StringBuffer和StringBuilder类似，最大的区别就是StringBuffer是线程安全的，看一下StringBuffer的append方法。 
```java
public synchronized StringBuffer append(String str) { 
    toStringCache = null; 
    super.append(str); 
    return this; 
} 
```
该方法使用synchronized进行声明，说明是一个线程安全的方法。而StringBuilder则不是线程安全的。 
## StringUtils.join是如何实现的 

通过查看StringUtils.join的源代码，我们可以发现，其实他也是通过StringBuilder来实现的。 
```java
public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) { 
    if (array == null) { 
        return null; 
    } 
    if (separator == null) { 
        separator = EMPTY; 
    } 

// endIndex - startIndex > 0:   Len = NofStrings *(len(firstString) + len(separator)) 
    //           (Assuming that all Strings are roughly equally long) 
    final int noOfItems = endIndex - startIndex; 
    if (noOfItems <= 0) { 
        return EMPTY; 
    } 

final StringBuilder buf = new StringBuilder(noOfItems * 16); 

for (int i = startIndex; i < endIndex; i++) { 
        if (i > startIndex) { 
            buf.append(separator); 
        } 
        if (array[i] != null) { 
            buf.append(array[i]); 
        } 
    } 
    return buf.toString(); 
} 
 ```
## 效率比较 
