# java 内存管理

## 一. java的内存结构

​	java虚拟机会将内存分派为几个不同的管理区， 这些区域各自有各自的用途，根据不同的特点，根据不同的任务以及在垃圾回收时运用的不同算法。总体分为以下几个部分：



### 1.  程序计数器（Program Counter Register）

​	这是一块儿比较小的内存，不在Ram上，二十直接分配在CPU上， 程序员无法直接操作它，他的作用是：JVM在解释字节码文件(.class)时，存储当前线程所执行的字节码行号，只是一种概念模型，各自JVM所采用的方式不同，字节码解释器工作时，就是通过改变程序计数器的值来选取下一条要执行的命令，分支、循环、跳转等基础功能都是依赖此技术去完成。还有一种情况，就是我们常说的JAVA多线程方面的，多线程就是通过线程的轮流切换而达到的，同一时刻，一个内核只能执行一个指令，==所以对于每一个程序来说，必须有一个计数器来记录程序的执行进度，这样，当线程恢复执行的时候，才能从正确的地方开始。所以，每个线程都要有一个独立的程序计数器，这类计数器为线程私有的内存。==如果一个线程正在执行一个java方法，则计数器记录的时字节码的指令地址，如果执行一个Native方法，则计数器记录为空，此内存区市唯一一个在java规范那种没有任何`OutOfMemoryError`情况的区域。

### 2. JVM虚拟机栈（JVM Stack）

​	JVM虚拟机栈就是我们常说的堆栈的栈（我们常常把内存粗略分为堆和栈），和程序计数器一样，也是==线程私有的，生命周期和线程一样，每个方法被执行的时候会产生一个**栈帧**，用于存储局部变量表、动态链接、操作数、方法出口等信息。方法的实行过程就是**栈帧**在JVM中出栈和入栈的过程。==局部变量表中存放各种基础数据类型：如`boolean`、`byte`、`char`等八种，以及引用类型（存放的是指向各个对象的内存地址），因此，他们有一个特点：==内存空间在编译期间就确定，运行期不会改变。==这个内存区域会有两种可能的java异常：`StackOverFlowError`和`OutOfMemoryError`。

### 3. 本地方法栈 （Native Method Stacks）

​	从名字可以看出，==本地方法栈就是用来处理java的本地方法的==，java类的祖先类object中有众多Native方法（<u>Native Method就是一个java调用非java代码的接口。</u>），如`hashCode()`,`wait()`等，他们的执行很多时候是借助于操作系统，但是JVM需要对他们做一些规范，来处理他们的执行过程。此区域，可以有不同的实现方法，像我们常用的SUN的JVM就是本地方法和JVM虚拟机栈是同一个。

### 4. 堆（Heap）

​	堆内存是内存中最重要的一块儿， 也是有必要进行深究的一部分。 因为java性能的优化，主要是针对这部分内存的。==所有的对象实例及数组都是在堆上面进行分配的（随着jit技术的逐渐成熟，这句话似乎有些绝对，不过至少目前还基本是这样的）。==可通过`-xmx`和`-xms`来控制堆的大小。JIT技术的发展产生了新的技术，如栈上分配的标量替换，也许在不久的几年里，即时编译会诞生及成熟，那个时候，“所有的对象实例和数组都是在堆上分配的”这句话就应该稍微改改了。堆内存是垃圾回收的主要区域，所以在下文**垃圾回收板块**会重点介绍，此处只做概念方面的解释。在32位系统上最大为2G，64位系统上无限制。`-xms`为JVM启动时申请的最小内存，`-xmx`为JVM可申请的最大堆内存。

### 5. 方法区 （Method Area）

​	方法区是所有线程共享的内存区域，用于==存储已经被JVM加载的类信息、常量、静态变量==等数据，一般来说，方法区属于**持久带**（持久带、新生代、旧生代），也难怪JAVA贵方将方法区描述为**堆**的一个逻辑部分，但它并不是**堆**。方法区的垃圾回收比较棘手，就算是SUN的**HotSpotVM**在这方面也没做n得多么完美。此处引入方法区的一个重要概念：**运行时常量池**。主要用于存放在编译过程中产生的**字面量**（字面量简单理解就是常量）和**引用** 。一般情况，常量的内存分配在变异期间就能确定，但不一定全是，有一些可能就是在运行时也可将常量放入常量池中，如String类中有个Native方法`Intern()`。

​	此处补充一个在JVM内存管理之外的内存区：==直接内存。==在JDK1.4中新加入类NIO类，引入了一种基于通道与缓冲区的I/O方式，它可以用Native函数直接分配堆外内存，即我们说的直接内存，这样在某些场景中会提高程序性能。